### Sql 执行的优化

#### 基于`成本`的优化

```
单表查询的时候，主要就是对这个表的多种访问方式（全表查询 ，各个索引查询）来根据一定的公式计算出来每种访问方式的成本，接着选择一个成本最低的访问方式，那么就可以确定下来这个表怎么访问了
```

- **IO 成本**
  
  - 规定**读一页的成本为 `1.0`**
- **CPU 成本**
  - 数据读取和校验
  - 规定读取和检测**一条数据的成本时 `0.2`**

- 全表扫描的成本计算方法

  - 查询表的统计信息：**show table status like "表名"**

  - 查看返回的 **rows(InnoDB 是估计值) --> 数据函数** 和 **data_length --> 表的聚簇索引的字节数大小** 信息

  - 成本粗略计算公式

    > **IO 成本**：`data_length/1024/16 * 1.0 + 微调值`
    >
    > **CPU 成本**：`rows * 0.2 + 微调值`



#### 基于`规则`的优化

- IN 语句结合子查询的优化手段
  - **select * from t1 where x1 in (select x2 from t2 where x3=xxx)**
  - 先**执行子查询，把结果写入一个临时表(物化表)**中，可能基于 memory 存储引擎存放在内存中，如果结果集太大，还可能采用普通 B+ 树聚簇索引的方式放入磁盘，无论如何都会**建立索引**
- semi join 半连接
  - **select * from t1 where x1 in (select x2 from t2 where
    x3=xxx)**
  - 转为 **select t1.* from t1 semi join t2 on t1.x1=t2.x2 and t2.x3=xxx**

