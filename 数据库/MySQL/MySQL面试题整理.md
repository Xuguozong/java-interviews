### 1. varchar 与 char 的区别？varchar(50)中50的含义？
- char是固定长度类型，varchar是一种可变长度类型
- 50表示最多存放50个字符。**varchar(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存**，因为 ORDER BY col 采用 fixed_length 计算 col 长度(memory引擎也一样)。

### 2. int(11)中的11什么含义？
- 不影响字段存储范围，**只影响展示效果**

### 3. 自增主键ID的删除策略
- InnoDB 表只把自增主键的最大ID记录到内存中，**重启丢失**
- MyISAM 表会把自增主键的最大ID记录到数据文件中，**重启不丢失**

### 4. 表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?
- 拆带来的问题：连接消耗 + 存储拆分空间
    如果能容忍拆分带来的空间问题，**拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序 IO** ，减少连接消耗，最后这是一个文本列再加上一个**全文索引**来尽量抵消连接消耗
- 不拆可能带来的问题：查询性能
  
### 5. 如何选择合适的存储引擎？
- 是否需要支持**事务**
- 对**索引和缓存**的支持
- 是否需要使用热备
- 崩溃恢复，是否接受崩溃
- 存储的限制
- 是否需要外键支持

### 6. InnoDB 与 MyISAM 的区别

特性 | InnoDB | MyISAM
---| ---|---
事务 | 支持 | 不支持
存储限制 | 64TB | 无
锁粒度 | 行锁 | 表锁
崩溃恢复 | 支持 | 不支持
外键 | 支持 | 不支持
全文检索 | 5.7后支持 | 不支持

### 7. InnoDB 的4大特性
- 插入缓冲（insert buffer）
- 二次写（double write）
- 自适应哈希索引（ahi）
- 预读（read ahead）

### 8. 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？
- 对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 **MyISAM 内部维持了一个计数器，预存了结果**，所以直接返回即可。

### 9. 索引的类型
- 普通索引：最基本的索引，没有任何约束
- 唯一索引：有唯一性约束
- 主键索引：特殊的唯一索引，不允许有空值
- 复合索引：将多个列组合在一起创建索引，可以覆盖多个列
- 外键索引：保证数据一致性/完整性和实现级联操作
- 全文索引：只能用于InnoDB和MyISAM，只能对英文进行全文索引，一般使用全文索引引擎

### 10. 索引的创建原则
- 最适合索引的列是出现在 **WHERE 子句中的列，或连接子句**中的列，而不是出现在 SELECT 关键字后的列
- 索引列的基数越大，索引效果越好
    索引基数（cardinality）：索引中`不重复的索引值`的数量
    https://blog.csdn.net/mingyundezuoan/article/details/79038989
- 根据情况创建复合索引，复合索引可以提高查询效率
    **复合索引的基数会更大**
- 避免创建过多索引（会额外占用空间，降低写操作的效率）
- 主键尽量选择**较短的数据类型**，可以有效减少索引占据的磁盘空间
- 对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间

### 11. 索引的使用注意事项
- 尽量避免在 WHERE 子句中使用 != 或 <> 操作符（全表扫描）
- 尽量避免在 WHERE 子句中使用 OR 来连接条件（全表扫描）
- 尽量避免在 WHERE 子句中对字段进行函数操作（全表扫描）
- 尽量避免在 WHERE 子句中对字段进行表达式操作（全表扫描）
- 尽量避免在 WHERE 子句中的 = 左边进行函数/算术运算或其他表达式运算，否则系统可能无法正确使用索引
- 复合索引遵循前缀原则
- 如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。可以在语句中添加强制索引来避免
- 列类型是字符串类型，查询时一定要**给值加引号**，否则索引失效
- LIKE 查询，% 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用**全文索引**或者上搜索引擎ES

### 12. 以下 3 条 SQL 如何建索引，只建一条怎么建？

    WHERE a = 1 AND b = 1
    WHERE b = 1
    WHERE b = 1 ORDER BY time DESC

- 以顺序b,a,time建立复合索引， create index tablename_b_a_time on index_test(b,a,time)
- 对于第一条 sql，因为最新版本的MySQL会优化 WHERE 子句后面的列顺序，以配合复合索引类型

### 13. 两种索引方式
- B-Tree 索引
- Hash 索引

### 14. MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？
    InnoDB 是基于索引来完成行锁。例如：SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE 。
    FOR UPDATE 可以根据条件来完成行锁锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起。

### 15. MySql 在访问页面时的大致过程
>  以修改一条记录为例

1. 优化器先通过各种手段分析出语句对应的**扫描区间和边界条件**
2. 优化器让InnoDB取出扫描区间的第一条记录
3. InnoDB先去对应索引的根页面去找（如果不在buffer pool里先加载到buffer pool里再访问，其他页面也是如此），逐层向下找，在叶子节点中定位到扫描区间中的第一条记录（访问页面就是访问共享数据结构，都需要加读写锁，非事务锁，这个对用户无影响可忽略）
4. 定位到记录后，先对这条记录加锁（这是事务锁，加锁就是生成对应的锁结构，加什么类型的锁书里详细有讨论），然后回表，对聚簇索引记录加锁，然后返回给server层
5. server层判断其余条件是否满足，满足则开始让InnoDB修改这条记录
6. 写对应的undo日志（会经过各种分配undo页面过程，undo页面不在buffer pool里也要加载到buffer pool里再处理，后边就不强调了），写undo是一个改页面的过程，也要先记录相应的redo日志（redo日志格式，以及怎么写redo我们在书里详细说了）
7. 真正修改数据页的内容（再一次强调，**数据页是共享内存结构，修改前需要获取读写锁**，这是和用户无关的，但是修改完成前别的事务是不可以访问这个页面的），当然，修改数据页的时候也要记录相应的redo日志，修改页面完成后，将其加入flush链表。修改完成后报告server层
8. server层再让InnoDB报告下一条记录，走到第4步执行（一个扫描区间，除第一条记录需要从B+树根节点定位外，其余记录都可以沿着next_record组成的链表向后遍历）



### 16. 索引失效的场景

- 有 or 必全有索引
- 复合索引未用左列字段
- like 以 % 开头
- 需要类型转换
- where 中索引列有运算或使用了函数
- MySQL 觉得全表扫描更快时(数据少)



### 17. 内连接和外连接的区别

- 内连接只取两表相对的结果集
- 左外连接除了取相交的部分还会取左表所有数据，其他不匹配的部分全部置 null
- 右外连接和左外连接则相反

