## 操作系统中的锁



## Java 中的锁



## Java 中的锁优化

### 自旋锁和自适应自旋

*引入背景*

```
互斥同步->阻塞实现->线程切换（内核操作）->性能影响->实际上：共享数据只会锁定很短时间
```

*优化手段*

```
1. 自旋等待：空循环忙等->会占用处理器时间

2. 适应性自旋：JDK 1.6 对自旋锁的优化 -> 根据前一次在同一个锁上的自选时间及锁的拥有者状态决定自旋等待时间及次数 -> 多的更多，少的更少(可能直接跳过自旋进入阻塞)
```

### 锁消除

```
即时编译器在运行时，对不可能存在共享数据竞争的锁进行消除
判定依据：逃逸分析的数据支持
```

### 锁粗化

```
避免一系列的连续操作对同一对象反复加解锁，与锁细化相对
```

### 轻量级锁

*引入背景*

```
JDK 1.6 引入，“轻量”是相对于使用操作系统互斥量来实现的传统锁而言的
```

*设计初衷*

```
在没有多线程竞争的前提下，改善重量级锁的性能消耗
```

// todo