**导学问题：**

1. 类加载机制是为了解决程序运行生命周期中的什么问题，这类问题有什么共性？
   - 图灵机是如何执行程序的？
2. JVM 类加载机制是如何解决这个问题的？其他语言是怎么解决的，有什么异同点？
3. 类加载机制的具体步骤，步骤间的顺序性如何？
4. 类加载机制为何要这样设计？



### 虚拟机类加载机制的定义

```
JVM 把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程就叫做虚拟机的类加载机制。
```

### ClassLoaderData(CLD)

> 用于存放类加载器相关的数据

- 所有被该 ClassLoader 加载的类
- 当前类加载器的 Java 对象表示
- 管理内存的 metaspace 等等
- 当前类加载器是否存活、是否需要卸载等等
- next 指针指向下一个 CLD，所有 CLD 组成 CLD 图，即 ClassLoaderDataGraph
- 通过调用 ClassLoaderDataGraph::classes_do 可以在 GC 中很容易的遍历找到所有类加载器加载的类

### 类加载的时机

1. 生命周期
   - 加载 - ClassLoader::load_class()
     - 分配 InstanceKlass 所需内存(InstanceKlass::allocate_instance_class)
     - 使用 parse_stream 得到的数据填充 InstanceKlass 的字段
     - 如果引入了 miranda 方法，设置对应 flag(set_has_miranda_methods)
     - 初始化 itable (klassItable::setup_itable_offset_table)
     - 舒适化 OopMapBlock(fill_oop_maps)
     - 分配 klass 对应的 java.lang.Class,在 Java 层描述类(java_lang_Class::create_mirror)
     - 生成 java8 的 default 方法（DefaultMethods::generate_default_methods)
  - 得到完整的 InstanceKlass
   - 链接
     - 验证
     - 准备
     - 解析 - ClassFileParser::parse_stream()
   - 初始化
   - 使用
   - 卸载

2. 加载 --> 验证 --> 准备 --> 初始化 --> 卸载这五个阶段的顺序是确定的



### 类加载的过程

### 1. 加载

#### 1）类数据来源

**通过`类的全限定名`来获取定义此类的二进制字节流**

```
没有限定来源，只要符合JVM规范即可，
可以来自文件(.class文件)、网络(Web Aplplet)、ZIP包(jar/war)、运行时生成(动态代理,
lava.lang.reflect.Proxy,ProxyGenerator.generateProxyClass())、其他文件(JSP)等等
```

**`类加载阶段`是开发人员`可控性最强`的阶段，可以自定义类的加载器，重写ClasssLoader#`findClass()`或ClasssLoader#`loadClass()`方法**

> 注意：`数组类`本身不通过类加载器创建，由 JVM `直接在内存中动态构建出来`

#### 2）类数据存储

> 二进制字节流按JVM设置的格式存储在`方法区`之中

#### 3）类数据去向

> 存储完成后，JVM 会创建一个 java.lang.Class 类的对象，作为程序访问方法区中的类型数据的外部接口



### 2. 验证

**这一阶段的目标是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求**

*主要验证项*

1. `文件格式`验证

   > 魔数、版本号、常量池常量类型等等
   
2. `元数据`验证

   > 语义分析，是否符合Java`语言规范`，是否有父类，final，接口，抽象类的规则等等
   
3. `字节码`验证

   >  通过数据流和控制流分析对类的方法体(Class文件中的Code属性)进行校验分析，最复杂
   
4. `符号引用`验证

   >  对类`自身以外`(常量池中的各类符号引用)的各类信息进行匹配性校验，发生在`符号引用转化为直接引用的阶段`(解析阶段)



### 3. 准备

**正式为`类变量(静态变量)分配内存并设置变量默认初始值`(注意不是最终代码中指定的值，这个在初始化阶段执行)**



### 4. 解析

**`将常量池内的符号引用替换为直接引用的过程`**

> **`符号引用`**

```
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。
符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。
比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。
各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。
```

> **`直接引用`**

```
直接引用可以是
（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
（3）一个能间接定位到目标的句柄
直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了
```



```
主要包括以下解析内容：
1. 类或接口的解析
2. 字段解析
3. 方法解析
4. 接口方法的解析
```



### 5. 初始化

**初始化阶段就是执行`类构造器<clinit>()方法`的过程**

```
<clinit>() 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，
编译器收集的顺序是由语句在源文件中出现的顺序决定的
```



## 类加载器

**类的唯一性 = 类的全限定名 + 此类的类加载器(独立的类命名空间)**

### 1. 层次

**A. `启功类`加载器 Bootstrap Class Loader**

> 加载${JAVA_HOME}/lib 包下指定文件名 jar 包（rt.jar,tools.jar），如果需要它加载，`指定类加载器为 null`，C++语言实现

**B. `扩展类`加载器 Extension Class Loader**

> 加载${JAVA_HOME}/lib/ext 目录下的类库，Java 实现

**C `应用类`加载器 Application Class Loader**

> 加载用户路径(ClassPath)下的类库，Java 实现

**D. `自定义`类加载器 User Class Loader**



### 2. 双亲委派模型

**加载器对类的加载首先委托自己的父类加载器去加载，父类加载不了的自己采取加载**

```
好处：形成了带有优先级的层次关系，如 Object 类始终由顶层的启动类加载器加载
```



### 3. 对双亲委派模型的 3 次破坏

1. JDK 1.2 引入此模型，自定义Class Loader已经使用，为了兼容添加新的 protected findClass()方法

2. 由于模型自身缺陷，基础类型不能调用回用户代码，如 JNDI 需要调用产商自己实现的 SPI

   ```
   解决：
   引入线程上下文类加载器 Thread Context Class Loader 这个类加载器可以通过 Thread#setContextClassLoader()方法设置，
   如果线程创建时为设置会从父线程继承一个，如果父线程也没有，默认使用应用类加载器
   这是一种父类加载器去请求子类加载器完成类加载的行为
   ```

3. 代码热替换、模块热部署，如 OSGi  实现模块化热部署的关键是它自定义的类加载器机制的实现