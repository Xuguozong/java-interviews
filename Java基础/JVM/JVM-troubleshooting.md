# Oracle MOOC: Java Virtual Machine Troubleshooting (2018)
By Poonam Parhar

https://apexapps.oracle.com/pls/apex/f?p=44785:17:107399788285250::NO:RP:P17_PAGE_ID,P17_EVENT_ID,P17_COURSE_ID,P17_PREV_PAGE:1266,5688,124,

**Interesting tools**
* JConsole
* Oracle Java Mission Control
 - Plugin JOverflow for Java Mission Control
* VisualVM
* Eclipse MAT (for heap dump analysis)
* jhat
* Yourkit (commercial)
* FlameGraphs:
  * https://github.com/brendangregg/FlameGraph
  * https://www.youtube.com/watch?v=go5oC5fmP9Y
  * How to do it? Java Flight Recorder, Perf...


## Week 1: Hotspot JVM Memory Management
### Lesson 1-1: HotSpot JVM Memory Management
* Video: https://youtu.be/nPSOAy4udfE
* Heap memory
* Root set: references from the outside of the heap memory, needed by the program execution state.
* The objects referenced by the root set must always be kept
* Compactation: once some objects are removed, the rest are put together, allowing free contiguous space.
* HotSpot JVM uses automatic memory management
• Garbage collector is responsible for
  - Memory allocation
  - Keeping the referenced objects in memory
  - Reclaiming the space used by unreachable objects
* Unreachable objects are called garbage
* This whole process of reclaiming memory is garbage collection

### Lesson 1-2:Generational Garbage Collection and Memory Spaces in the HotSpot JVM
* Video: https://www.youtube.com/watch?v=9Z3EkWW-my8
* Memory space is divided into generations
* Separate pools holding objects of different age ranges
* Based on hypothesis:
  - Most allocated objects die young
  - Few references from older to younger objects exist
* To take advantage of this hypothesis, heap is divided into two generations
  - Young: small and collected frequently
  - Old : larger and occupancy grows slowly
* Minor(young) and Major(Full) collections
* Young: Eden, Survivor, Survival, Virtual
  * Initially in Eden, and then moved to the Survivor spaces.
* Old: x and Virtual
* Uncommited space: the Virtual ones. The spaces (young and old) can group up to the Virtual ones.
* The objects which survive a certain number of collections, are moved to the Old Generation.
* Prior to JDK 8, there was a third space: the Permanent Generation (PermGen): JVM internal representation of classes and metadata, class statics, Interned Strings.
* From JDK 8, there is no Permanent Generation, it has been substitued by the Metaspace space.
  * it stores class metadata
  * non contiguous with the heap space.
  * it can take up to the system memory (it can be limited).
* Code Cache
  * Code Cache is used to store the compiled code generated by the Just-in-
time compilers
  * It is allocated out of native memory
  * Managed by the Code Cache Sweeper
* Native Memory
  * Available system memory
  * Not managed by the JVM memory management
* Oracle Java Mission Control: monitoring of the JVM

### Lesson 1-3: Garbage Collectors in the HotSpot JVM
* Video: https://www.youtube.com/embed/rrvAA615jPU?rel=0&autoplay=1
* HotSpot Garbage Collection Types
  * Young Generation Collection
    – Serial is a stop-the-world, copying collector that uses a single GC thread
    – ParNew is a stop-the-world, copying collector that uses multiple GC threads
    – Parallel Scavenge is a stop-the-world, copying collector that uses multiple GC threads
  * Old Generation Collection
    – Serial Old is a stop-the-world, mark-sweep-compact collector that uses a single GC thread
    – CMS (Concurrent Mark Sweep) is a mostly concurrent, low-pause collector
    – Parallel Old is a compacting collector that uses multiple GC threads
  * G1 is the Garbage First collector for large heaps and provides reliable short
  * GC pauses
    – Has generations but uses different memory layout
  * Young: it exists the "From Survivor" and "To Survivor". After a collection, the swap.

## Week 2: Dissecting Memory Problems
* Causes of memory problems:
  * Misconfiguration of Memory Spaces
  * Memory Leaks
  * Excessive use of Finalizers
  * Explicit GC Invocations
* Finalizers are being deprecated in Java 9
* Metaspace, by default, is unlimited. You must set a parameter to limit it (if you want to).
* What is Native Memory? (the one not managed by JVM):
  * Java Thread Stacks
  * Loaded jar and zip files
  * Loaded native libraries
  * Native resources e.g. files
  * Memory allocated from the native code e.g. JNI


## Week 3: Diagnostic Data Collection and Analysis Tools
* Heap size: set the initial heap size (-Xms) like the maximum heap size (-Xmx)
* We can get info from GC logs, Heap dumps (jcmd, jmap, jconsole, jmc, etc.), Heap Histograms, Flight Recordings, etc.
* **GCTimeLimit** sets an upper limit on the amount of time that GCs can spend in percent of the total time
 – Its default value is 98%
 – Decreasing this value reduces the amount of time allowed that can be spent in the garbage collections
* **GCHeapFreeLimit** sets a lower limit on the amount of space that should be free after the garbage collections, represented as percent of the maximum heap
* The Flight Recordings can take us as far as determining the type of objects that are leaking but to find out what is causing those objects to leak, we require heap dumps.
* GC Logs Analysis. What do we want to look for:
 – Are there too many Full GCs?
 – Are there GCs with long pauses?
 – Are there GCs happening too frequently?
* Automatic Analysis tools: GCHisto, GCViewer, gceasy.io etc.
* Heap dump analysis
 - Eclipse MAT
 - Plugin JOverflow for Java Mission Control
 * Java VisualVM: all-in-one tool
 * jhat (removed in JDK 9)
* The heap taken with Flight Recordings can be analyzed with tools above.
* **Finalization**
 * OutOfMemoryError can also be caused due to excessive use of finalizers
 * Objects with a finalizer (i.e. a finalize() method) may delay the reclamation
 of the space occupied by them
 * Finalizer thread needs to invoke the finalize() method of the instances
 before those instances can be reclaimed
 * If the Finalizer thread does not keep up with the rate at which the objects
 become eligible for finalization, JVM might fail with an OutOfMemoryError
* Diagnostic tools for finalization: JConsole, jmap and heap dumps.
* Eclipse MAT offers a very nice feature called 'Duplicate Classes'
* CodeCache is the memory pool to store the compiled code generated by the JIT compilers.
* The Native Memory Tracker (NMT) can be used to track native memory that is used internally by the JVM.


## Resources
* https://docs.oracle.com/javase/9/gctuning/toc.htm
* https://en.wikipedia.org/wiki/HotSpot
* Java SE HotSpot at a Glance: http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-136373.html
* https://dzone.com/articles/understanding-garbage-collection-log