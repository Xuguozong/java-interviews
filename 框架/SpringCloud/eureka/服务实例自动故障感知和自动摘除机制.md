### 自动故障感知机制

> eureka靠的是心跳，来感知，可能某个服务已经挂掉了，就不会再发送心跳了，如果在一段时间内没有接收到某个服务的心跳，那么就将这个服务实例给摘除，认为这个服务实例已经宕机了

- EurekaBootStrap#initEurekaServerContext
- registry.openForTraffic(applicationInfoManager, registryCount) --> PeerAwareInstanceRegistry.openForTraffic()方法里，最后隐藏了一行调用，postInit()
- **每隔60s**会运行一次定时调度的后台线程任务，**EvictionTask**



### 自动摘除机制

- 获取一个补偿时间，是为了避免说EvictionTask两次调度的时间超过了设置的60s，**补偿时间的机制**，大家可以学习一下这个东西的使用

19:55:00 3分钟 19:58:00 -> 过期

EvictionTask本身调度的就慢了，比上一次该调度的时间晚了92s

19:55:00过后，3分钟内没有心跳，在他延迟的这92s之内，也没心跳，19:59:32，都没心跳发送过，才能认为是失效

- 遍历注册表中所有的服务实例，然后调用**Lease的isExpired()**方法，来判断当前这个服务实例的租约是否过期了，是否失效了，服务实例故障了，如果是故障的服务实例，加入一个列表。**如果上次的心跳到现在间隔了90s * 2 = 180s，3分钟，才会认为是故障了**。闪光点，突出你的牛的地方，**eureka bug**。

- 不会一次性将所有故障的服务实例都摘除，**每次最多将注册表中15%的服务实例给摘除掉，所以一次没摘除所有的故障实例**，下次EvictionTask再次执行的时候，会再次摘除，**分批摘取机制**

- 在摘除的时候，是从故障实例中**随机挑选**本次可以摘除的数量的服务实例，来摘除，**随机摘取机制**

- 摘除服务实例的时候，其实就是调用下线的方法，**internelCancel()方法**，注册表、recentChangeQueue、invalidate缓存